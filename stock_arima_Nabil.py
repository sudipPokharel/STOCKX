# -*- coding: utf-8 -*-
"""STOCK_ARIMA_.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1yAo7TurJrrUCW657l-Xmi4wm0vnKP2Wx
"""

import pandas as pd
import json
import os
import requests
from datetime import datetime, timezone
import matplotlib as plt
from sklearn.preprocessing import MinMaxScaler
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_squared_error,r2_score
import numpy as np

from tensorflow.keras.layers import Dropout

!pip install pmdarima

url = "https://merolagani.com/handlers/TechnicalChartHandler.ashx?type=get_advanced_chart&symbol=NABIL&resolution=1D&rangeStartDate=1514744100&rangeEndDate=1765793017&from=&isAdjust=1&currencyCode=NPR"
response = requests.get(url)
data = response.json()


with open("NABIL.json", "w") as f:
    json.dump(data, f)

companies = ["/content/NABIL.json"]

for symbol in companies:
    with open(f"{symbol}", 'r') as f:
        data = json.load(f)
        print(data)
    dates = [datetime.fromtimestamp(ts, tz=timezone.utc).strftime('%Y-%m-%d') for ts in data['t']]
    df=pd.DataFrame({
    "Date":dates,
    "Open":data['o'],
    "Close":data['c'],
    "High":data['h'],
    "Low":data['l'],
    "Volume":data['v']

})
    csv_filename = os.path.basename(symbol).replace('.json', '.csv')
    print(csv_filename)
    df.to_csv(csv_filename,index=False)
    print(f"{csv_filename}created")

df = pd.read_csv("NABIL.csv")
df['Date'] = pd.to_datetime(df['Date'])
df = df.set_index('Date')
print(len(df))

def plot_graph(figsize, df_to_plot, column_name):
    # df_to_plot is already assumed to have 'Date' as its index
    df_to_plot = df_to_plot.sort_index()

    plt.figure(figsize=figsize)
    plt.plot(df_to_plot.index, df_to_plot[column_name], label=column_name)
    plt.title(f"NABIL {column_name} Over Time")
    plt.xlabel("Date")
    plt.ylabel(column_name)
    plt.legend()
    plt.show()

import matplotlib.pyplot as plt
plot_graph((10, 5), df, "Close")

to_row=int(len(df)*0.8)
training_data=list(df[0:to_row]['Close'])
testing_data=list(df[to_row:]['Close'])

testing_data

plt.figure(figsize=(10,6))
plt.grid(True)
plt.xlabel('Date')
plt.ylabel('Close Price')
plt.plot(df[0:to_row]['Close'],'green',label='Train data')
plt.plot(df[to_row:]['Close'],'blue',label='Test data')
plt.legend()
plt.show()

model_predictions=[]
n_test_obser = len(testing_data)

model_predictions=[] # Re-initialize as a list
n_test_obser = len(testing_data)

for i in range(n_test_obser):
  model= ARIMA(training_data,order=(4,1,0))

  model_fit = model.fit()

  output = model_fit.forecast()

  model_predictions.append(output)
  actual_test_value = testing_data[i]

  training_data.append(actual_test_value)
  print(output)

print(model_fit.summary())

print(type(model_predictions))
print(np.array(model_predictions).shape)
print(model_predictions)

import numpy as np
# Ensure model_predictions is a 1D NumPy array of scalar values
# Each element in model_predictions is currently a single-element NumPy array (e.g., array([value]))
# We extract the scalar from each and create a new 1D array.
model_predictions = np.array([p.item() for p in model_predictions])

print(type(model_predictions), np.array(model_predictions).shape)

plt.figure(figsize=(10,6))
plt.grid(True)

date_range = df[to_row:].index
plt.plot(date_range, model_predictions, color='blue',marker='o',linestyle='dashed',label='Nabil predicted price')
plt.plot(date_range, testing_data,color='red',label='Nabil actual price')

plt.title('Nabil price prediction')
plt.xlabel('Date')
plt.ylabel('Price')
plt.legend()
plt.show()

mape= np.mean(np.abs(np.array(model_predictions)-np.array(testing_data))/np.array(testing_data))
print('Mape:'+str(mape))

#TRUE FORECASTING


import numpy as np
import matplotlib.pyplot as plt
from statsmodels.tsa.arima.model import ARIMA

to_row = int(len(df) * 0.8)

training_data = df[:to_row]['Close']
testing_data  = df[to_row:]['Close']

plt.figure(figsize=(10,6))
plt.grid(True)

plt.plot(training_data.index, training_data, label='Train data', color='green')
plt.plot(testing_data.index, testing_data, label='Test data', color='blue')

plt.xlabel('Date')
plt.ylabel('Close Price')
plt.legend()
plt.show()

model = ARIMA(training_data, order=(4,1,0))
model_fit = model.fit()

print(model_fit.summary())

n_forecast = len(testing_data)

forecast = model_fit.forecast(steps=n_forecast)
forecast = np.array(forecast)

plt.figure(figsize=(10,6))
plt.grid(True)

plt.plot(training_data.index, training_data, label='Train data', color='green')
plt.plot(testing_data.index, testing_data, label='Actual future price', color='red')

plt.plot(
    testing_data.index,
    forecast,
    label='ARIMA future forecast',
    linestyle='dashed',
    marker='o'
)

plt.title('Nabil TRUE Future Price Forecast (ARIMA)')
plt.xlabel('Date')
plt.ylabel('Price')
plt.legend()
plt.show()

future_steps = 30
future_forecast = model_fit.forecast(steps=future_steps)

future_dates = pd.date_range(
    start=df.index[-1],
    periods=future_steps + 1,
    freq='B'  # business days
)[1:]

plt.figure(figsize=(10,6))
plt.grid(True)

plt.plot(df.index, df['Close'], label='Historical price')
plt.plot(future_dates, future_forecast, label='Future forecast', linestyle='dashed')

plt.title('30-Day Future Forecast')
plt.xlabel('Date')
plt.ylabel('Price')
plt.legend()
plt.show()

"""#analyzed"""

from statsmodels.tsa.stattools import adfuller
def check_stationarity(df):
    result = adfuller(df)
    print('ADF Statistic:%f' % result[0])
    print('p-value:%f' % result[1])
    if result[1] <= 0.05:
        print("Stationary")
    else:
        print("Non-Stationary")

#decompose the data for trend seasonality and noise
#d value

from statsmodels.tsa.seasonal import seasonal_decompose
decompose = seasonal_decompose(df['Close'],model='additive',period=30)
decompose.plot()
plt.show()

from statsmodels.graphics.tsaplots import plot_acf, plot_pacf
import matplotlib.pyplot as plt

# Create 3 rows, 2 columns for plots
fig, axes = plt.subplots(3, 2, figsize=(12, 12))

# Original Series
axes[0, 0].plot(df['Close'], color='blue')
axes[0, 0].set_title('Original Series')
plot_acf(df['Close'], ax=axes[0, 1])
axes[0, 1].set_title('ACF - Original Series')

# 1st Differencing
diff1 = df['Close'].diff().dropna()
axes[1, 0].plot(diff1, color='green')
axes[1, 0].set_title('1st Order Differencing')
plot_acf(diff1, ax=axes[1, 1])
axes[1, 1].set_title('ACF - 1st Order Differencing')

# 2nd Differencing
diff2 = diff1.diff().dropna()
axes[2, 0].plot(diff2, color='red')
axes[2, 0].set_title('2nd Order Differencing')
plot_acf(diff2, ax=axes[2, 1])
axes[2, 1].set_title('ACF - 2nd Order Differencing')

plt.tight_layout()
plt.show()

#p value

#plots

from statsmodels.graphics.tsaplots import plot_acf, plot_pacf
pd.plotting.autocorrelation_plot(df['Close'])

plot_acf(df['Close'],alpha=0.05)

plt.show()

from statsmodels.graphics.tsaplots import plot_pacf
import matplotlib.pyplot as plt

# diff1 = first-order differenced series to make it stationary
plot_pacf(diff1, lags=20)
plt.show()

from statsmodels.tsa.stattools import acf,pacf
x_acf = pd.DataFrame(acf(df['Close']))
print(x_acf)

from pmdarima.arima import auto_arima
model = auto_arima(df['Close'],start_p=1,start_q=1,max_p=5,max_q=5,m=12,start_P=0,seasonal=True,d=1,D=1,trace=True,error_action='ignore',suppress_warnings=True)

model.summary()

from statsmodels.tsa.arima.model import ARIMA
p,d,q = 2,1,0

model= ARIMA(df['Close'],order=(p,d,q))
model=model.fit()
model.summary()

#predict next 30 days

forecast= model.forecast(len(df['Close']),len(df['Close'])+30)
print(forecast)

forecast_obj = model.get_forecast(steps=30)

# Forecast values
forecast = forecast_obj.predicted_mean

# Confidence intervals
conf_int = forecast_obj.conf_int()

#sarima

import statsmodels.api as sm
import warnings

p,d,q=2,1,0

model = sm.tsa.statespace.SARIMAX(df['Close'],order=(p,d,q),
                                  seasonal_order=(p,d,q,12))

model = model.fit()
model.summary()

predictions = model.predict(start=len(df['Close']),end=len(df['Close'])+30)
print(predictions)

plt.figure(figsize=(14,6))
plt.plot(df['Close'], label='Actual')

# Create a date range for the predictions
last_date = df.index[-1]
forecast_dates = pd.date_range(start=last_date + pd.Timedelta(days=1), periods=len(predictions), freq='D')

# Assign the new date index to the predictions
predictions.index = forecast_dates

plt.plot(predictions, label='Forecasted', color='red')
plt.legend()
plt.show()

plt.figure(figsize=(14, 6))
plt.plot(df['Close'].tail(60), label='Recent Actual', color='blue') # Show last 60 days of actual data
plt.plot(predictions, label='Forecasted', color='red')

plt.title('Nabil Price Forecast')
plt.xlabel('Date')
plt.ylabel('Price')
plt.legend()
plt.grid(True)
plt.show()

"""### Interpreting the Forecast

In the zoomed-in plot above, the blue line represents the most recent actual closing prices for NABIL, and the red line shows the forecasted prices for the next 30 days generated by the SARIMA model. This view allows you to see the trend and specific values of the predictions more clearly.

To see the exact numerical values of the forecast, you can inspect the `predictions` Series directly:
"""

display(predictions)

